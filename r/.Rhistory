# r/duckdb_example.R
suppressPackageStartupMessages({
library(DBI)
library(duckdb)
library(readr)
library(fs)
})
# ---------------------------
# Configuración
# ---------------------------
anio <- "2025"
mes  <- "07"   # 01..12
duckdb_path <- "data/duckdb/madrid.duckdb"
cache_dir   <- "data/raw/historico"
# URL del ZIP mensual (formato MM-YYYY.zip)
zip_url <- sprintf("https://datos.madrid.es/egobfiles/MANUAL/208627/%s-%s.zip", mes, anio)
# Rutas locales
dir_create(cache_dir)
zip_local <- file.path(cache_dir, sprintf("%s-%s.zip", mes, anio))
# Nombre de tabla en DuckDB
tabla <- sprintf("trafico_%s_%s", anio, mes)
# ---------------------------
# Descarga con caché
# ---------------------------
if (!file_exists(zip_local)) {
message("Descargando: ", zip_url)
download.file(zip_url, destfile = zip_local, mode = "wb", quiet = TRUE)
} else {
message("Usando ZIP en caché: ", zip_local)
}
# ---------------------------
# Extraer y detectar el CSV
# ---------------------------
tmpdir <- tempdir()
files_in_zip <- unzip(zip_local, list = TRUE)
# Si el ZIP contiene múltiples ficheros, cogemos el primero CSV
csv_name <- files_in_zip$Name[grepl("\\.csv$", tolower(files_in_zip$Name))]
if (length(csv_name) == 0) stop("El ZIP no contiene ningún CSV.")
csv_name <- csv_name[1]
csv_path <- unzip(zip_local, files = csv_name, exdir = tmpdir, overwrite = TRUE)
message("CSV detectado en ZIP: ", basename(csv_path))
# ---------------------------
# Lectura del CSV
# - Separador ';'
# - Decimal '.'
# - Codificación: intentamos UTF-8 (ajustable si fuese necesario)
# ---------------------------
# Nota: si el fichero está en ISO-8859-1, usar locale(encoding = "Latin1")
df <- read_delim(
file   = csv_path,
delim  = ";",
locale = locale(decimal_mark = ".", grouping_mark = "", encoding = "UTF-8"),
show_col_types = FALSE,
progress = FALSE
)
# Intento opcional de parseo de fecha/hora si existe columna "fecha" o similar
posibles_fechas <- intersect(names(df), c("fecha", "Fecha", "FECHA", "fecha_hora", "datetime"))
if (length(posibles_fechas) > 0) {
col_f <- posibles_fechas[1]
# Intento común: "YYYY-MM-DD HH:MM:SS" o similar
suppressWarnings({
df[[col_f]] <- parse_datetime(df[[col_f]], locale = locale(tz = "UTC"))
})
}
# ---------------------------
# Conexión DuckDB y carga
# ---------------------------
con <- dbConnect(duckdb::duckdb(), duckdb_path)
# ---------------------------
# Conexión DuckDB y carga
# ---------------------------
con <- dbConnect(duckdb::duckdb(), duckdb_path)
on.exit({
try(dbDisconnect(con, shutdown = TRUE), silent = TRUE)
})
# Crea/reescribe la tabla
dbWriteTable(con, tabla, df, overwrite = TRUE, temporary = FALSE)
# Índice sobre fecha si existe
if ("fecha" %in% names(df)) {
try(DBI::dbExecute(con, sprintf("CREATE INDEX IF NOT EXISTS idx_%s_fecha ON %s(fecha)", tabla, tabla)), silent = TRUE)
} else if ("fecha_hora" %in% names(df)) {
try(DBI::dbExecute(con, sprintf("CREATE INDEX IF NOT EXISTS idx_%s_fecha_hora ON %s(fecha_hora)", tabla, tabla)), silent = TRUE)
}
# Verificación
res <- dbGetQuery(con, sprintf("SELECT COUNT(*) AS filas FROM %s", tabla))
# r/duckdb_example.R
# ---------------------------------------------
# Crear la base de datos
# Ejecutar desde la terminal:
#   ./duckdb data/duckdb/madrid.duckdb
# ---------------------------------------------
suppressPackageStartupMessages({
library(DBI)
library(duckdb)
library(readr)
library(fs)
})
# ---------------------------
# Configuración
# ---------------------------
anio <- "2025"
mes  <- "07"   # 01..12
duckdb_path <- "data/duckdb/madrid.duckdb"
cache_dir   <- "data/raw/historico"
# URL del ZIP mensual (formato MM-YYYY.zip)
zip_url <- sprintf("https://datos.madrid.es/egobfiles/MANUAL/208627/%s-%s.zip", mes, anio)
# Rutas locales
dir_create(cache_dir)
zip_local <- file.path(cache_dir, sprintf("%s-%s.zip", mes, anio))
# Nombre de tabla en DuckDB
tabla <- sprintf("trafico_%s_%s", anio, mes)
# ---------------------------
# Descarga con caché
# ---------------------------
if (!file_exists(zip_local)) {
message("Descargando: ", zip_url)
download.file(zip_url, destfile = zip_local, mode = "wb", quiet = TRUE)
} else {
message("Usando ZIP en caché: ", zip_local)
}
# ---------------------------
# Extraer y detectar el CSV
# ---------------------------
tmpdir <- tempdir()
files_in_zip <- unzip(zip_local, list = TRUE)
csv_name <- files_in_zip$Name[grepl("\\.csv$", tolower(files_in_zip$Name))]
if (length(csv_name) == 0) stop("El ZIP no contiene ningún CSV.")
csv_name <- csv_name[1]
csv_path <- unzip(zip_local, files = csv_name, exdir = tmpdir, overwrite = TRUE)
message("CSV detectado en ZIP: ", basename(csv_path))
# ---------------------------
# Lectura del CSV
# ---------------------------
df <- read_delim(
file   = csv_path,
delim  = ";",
locale = locale(decimal_mark = ".", grouping_mark = "", encoding = "UTF-8"),
show_col_types = FALSE,
progress = FALSE
)
# ---------------------------
# Normalización robusta de fechas
# ---------------------------
normaliza_datetime <- function(x) {
if (inherits(x, c("POSIXct", "POSIXt"))) return(x)
if (inherits(x, "Date")) return(as.POSIXct(x, tz = "UTC"))
if (is.numeric(x)) {
mx <- suppressWarnings(max(x, na.rm = TRUE))
if (is.finite(mx)) {
if (mx > 1e12) return(as.POSIXct(x/1000, origin = "1970-01-01", tz = "UTC"))
if (mx > 1e9)  return(as.POSIXct(x, origin = "1970-01-01", tz = "UTC"))
if (mx > 10000 && mx < 1e6) return(as.POSIXct(x * 86400, origin = "1899-12-30", tz = "UTC"))
}
return(x)
}
x_chr <- as.character(x)
readr::parse_datetime(x_chr, locale = readr::locale(tz = "UTC"))
}
posibles_fechas <- intersect(names(df), c("fecha", "Fecha", "FECHA", "fecha_hora", "datetime"))
if (length(posibles_fechas) > 0) {
col_f <- posibles_fechas[1]
df[[col_f]] <- normaliza_datetime(df[[col_f]])
}
# ---------------------------
# Conexión DuckDB y carga
# ---------------------------
con <- dbConnect(duckdb::duckdb(), duckdb_path)
on.exit({
try(dbDisconnect(con, shutdown = TRUE), silent = TRUE)
})
dbWriteTable(con, tabla, df, overwrite = TRUE, temporary = FALSE)
# Índice sobre fecha si existe
if ("fecha" %in% names(df)) {
try(DBI::dbExecute(con, sprintf("CREATE INDEX IF NOT EXISTS idx_%s_fecha ON %s(fecha)", tabla, tabla)), silent = TRUE)
} else if ("fecha_hora" %in% names(df)) {
try(DBI::dbExecute(con, sprintf("CREATE INDEX IF NOT EXISTS idx_%s_fecha_hora ON %s(fecha_hora)", tabla, tabla)), silent = TRUE)
}
res <- dbGetQuery(con, sprintf("SELECT COUNT(*) AS filas FROM %s", tabla))
# r/duckdb_example.R
# ---------------------------------------------
# Crear la base de datos (opcional, desde terminal):
#   ./duckdb data/duckdb/madrid.duckdb
# ---------------------------------------------
suppressPackageStartupMessages({
library(DBI)
library(duckdb)
library(readr)
library(fs)
})
# ---------------------------
# Configuración
# ---------------------------
anio <- "2025"
mes  <- "07"   # 01..12
duckdb_path <- "data/duckdb/madrid.duckdb"
cache_dir   <- "data/raw/historico"
# URL del ZIP mensual (formato MM-YYYY.zip)
zip_url <- sprintf("https://datos.madrid.es/egobfiles/MANUAL/208627/%s-%s.zip", mes, anio)
# Rutas locales
dir_create(cache_dir)
zip_local <- file.path(cache_dir, sprintf("%s-%s.zip", mes, anio))
# Nombre de tabla en DuckDB
tabla <- sprintf("trafico_%s_%s", anio, mes)
# ---------------------------
# Descarga con caché
# ---------------------------
if (!file_exists(zip_local)) {
message("Descargando: ", zip_url)
download.file(zip_url, destfile = zip_local, mode = "wb", quiet = TRUE)
} else {
message("Usando ZIP en caché: ", zip_local)
}
# ---------------------------
# Extraer y detectar el CSV
# ---------------------------
tmpdir <- tempdir()
files_in_zip <- unzip(zip_local, list = TRUE)
csv_name <- files_in_zip$Name[grepl("\\.csv$", tolower(files_in_zip$Name))]
if (length(csv_name) == 0) stop("El ZIP no contiene ningún CSV.")
csv_name <- csv_name[1]
csv_path <- unzip(zip_local, files = csv_name, exdir = tmpdir, overwrite = TRUE)
message("CSV detectado en ZIP: ", basename(csv_path))
# ---------------------------
# Conexión DuckDB
# ---------------------------
dir_create(dirname(duckdb_path))
con <- dbConnect(duckdb::duckdb(), duckdb_path)
on.exit({
try(dbDisconnect(con, shutdown = TRUE), silent = TRUE)
})
# ---------------------------
# Opción A: lectura directa del CSV por DuckDB
# (escapar comillas simples del path)
# ---------------------------
path_escaped <- gsub("'", "''", normalizePath(csv_path, winslash = "/", mustWork = FALSE), fixed = TRUE)
sql_create <- sprintf(
"CREATE OR REPLACE TABLE %s AS
SELECT * FROM read_csv_auto('%s', delim=';', header=TRUE, sample_size=-1);",
tabla, path_escaped
)
DBI::dbExecute(con, sql_create)
# Índices sobre fecha si existen
cols <- dbGetQuery(con, sprintf("PRAGMA table_info(%s);", tabla))$name
if ("fecha" %in% cols) {
DBI::dbExecute(con, sprintf("CREATE INDEX IF NOT EXISTS idx_%s_fecha ON %s(fecha);", tabla, tabla))
} else if ("fecha_hora" %in% cols) {
DBI::dbExecute(con, sprintf("CREATE INDEX IF NOT EXISTS idx_%s_fh ON %s(fecha_hora);", tabla, tabla))
}
# r/duckdb_example.R
# ---------------------------------------------
# Crear la base de datos (opcional, desde terminal):
#   ./duckdb data/duckdb/madrid.duckdb
# ---------------------------------------------
suppressPackageStartupMessages({
library(DBI)
library(duckdb)
library(readr)
library(fs)
})
# ---------------------------
# Configuración
# ---------------------------
anio <- "2025"
mes  <- "07"   # 01..12
duckdb_path <- "data/duckdb/madrid.duckdb"
cache_dir   <- "data/raw/historico"
# URL del ZIP mensual (formato MM-YYYY.zip)
zip_url <- sprintf("https://datos.madrid.es/egobfiles/MANUAL/208627/%s-%s.zip", mes, anio)
# Rutas locales
dir_create(cache_dir)
zip_local <- file.path(cache_dir, sprintf("%s-%s.zip", mes, anio))
# Nombre de tabla en DuckDB
tabla <- sprintf("trafico_%s_%s", anio, mes)
# ---------------------------
# Descarga con caché
# ---------------------------
if (!file_exists(zip_local)) {
message("Descargando: ", zip_url)
download.file(zip_url, destfile = zip_local, mode = "wb", quiet = TRUE)
} else {
message("Usando ZIP en caché: ", zip_local)
}
# ---------------------------
# Extraer y detectar el CSV
# ---------------------------
tmpdir <- tempdir()
files_in_zip <- unzip(zip_local, list = TRUE)
csv_name <- files_in_zip$Name[grepl("\\.csv$", tolower(files_in_zip$Name))]
if (length(csv_name) == 0) stop("El ZIP no contiene ningún CSV.")
csv_name <- csv_name[1]
csv_path <- unzip(zip_local, files = csv_name, exdir = tmpdir, overwrite = TRUE)
message("CSV detectado en ZIP: ", basename(csv_path))
# ---------------------------
# Conexión DuckDB
# ---------------------------
dir_create(dirname(duckdb_path))
con <- dbConnect(duckdb::duckdb(), duckdb_path)
on.exit({
try(dbDisconnect(con, shutdown = TRUE), silent = TRUE)
})
# ---------------------------
# Opción A: lectura directa del CSV por DuckDB
# (se evita pasar por data.frame en R)
# ---------------------------
path_escaped <- gsub("'", "''", normalizePath(csv_path, winslash = "/", mustWork = FALSE), fixed = TRUE)
sql_create <- sprintf(
"CREATE OR REPLACE TABLE %s AS
SELECT * FROM read_csv_auto('%s', delim=';', header=TRUE, sample_size=-1);",
tabla, path_escaped
)
DBI::dbExecute(con, sql_create)
# ---------------------------
# Workaround: crear columna temporal 'ts' y ordenar la tabla
# (evita el bug del ART index y acelera consultas por rango con zone maps)
# ---------------------------
# Detectar columna temporal existente
cols_df <- dbGetQuery(con, sprintf("PRAGMA table_info(%s);", tabla))
cols <- cols_df$name
time_col <- if ("fecha_hora" %in% cols) "fecha_hora" else if ("fecha" %in% cols) "fecha" else NA_character_
if (is.na(time_col)) stop("No se encontró columna temporal ('fecha_hora' o 'fecha').")
# Renombrar tabla actual a *_old
DBI::dbExecute(con, sprintf("ALTER TABLE %s RENAME TO %s_old;", tabla, tabla))
# Recrear tipando 'ts' con varios formatos comunes
sql_with_ts <- sprintf("
CREATE OR REPLACE TABLE %1$s AS
SELECT
t.*,
COALESCE(
try_strptime(CAST(t.%2$s AS VARCHAR), '%%Y-%%m-%%d %%H:%%M:%%S'),
try_strptime(CAST(t.%2$s AS VARCHAR), '%%d/%%m/%%Y %%H:%%M:%%S'),
try_strptime(CAST(t.%2$s AS VARCHAR), '%%Y/%%m/%%d %%H:%%M:%%S'),
try_strptime(CAST(t.%2$s AS VARCHAR), '%%Y-%%m-%%dT%%H:%%M:%%S'),
try_strptime(CAST(t.%2$s AS VARCHAR), '%%d/%%m/%%Y')
) AS ts
FROM %1$s_old t;
", tabla, time_col)
DBI::dbExecute(con, sql_with_ts)
# Ordenar físicamente por 'ts' para potenciar zone maps
DBI::dbExecute(con, sprintf("
CREATE OR REPLACE TABLE %1$s AS
SELECT * FROM %1$s ORDER BY ts NULLS LAST;
", tabla))
# Limpieza: eliminar tabla antigua y checkpoint
DBI::dbExecute(con, sprintf("DROP TABLE IF EXISTS %s_old;", tabla))
DBI::dbExecute(con, "CHECKPOINT;")
# ---------------------------
# Verificación
# ---------------------------
res <- dbGetQuery(con, sprintf("SELECT COUNT(*) AS filas, min(ts) AS ts_min, max(ts) AS ts_max FROM %s;", tabla))
print(res)
message(sprintf("Tabla '%s' creada/actualizada y ordenada por ts en %s", tabla, duckdb_path))
suppressPackageStartupMessages({
library(DBI)
library(duckdb)
library(dplyr)
library(ggplot2)
})
duckdb_path <- "data/duckdb/madrid.duckdb"
con <- DBI::dbConnect(duckdb::duckdb(), duckdb_path)
on.exit({ try(DBI::dbDisconnect(con, shutdown = TRUE), silent = TRUE) })
src_name <- if ("v_trafico_enriquecido" %in% DBI::dbListTables(con)) "v_trafico_enriquecido" else "trafico_2025_07"
time_col <- intersect(DBI::dbListFields(con, src_name), c("ts", "fecha_hora"))[1]
serie <- tbl(con, dplyr::sql(sprintf("
SELECT date_trunc('minute', %s) AS minuto,
avg(intensidad) AS intensidad_media
FROM %s
WHERE %s >= now() - INTERVAL 2 HOUR
GROUP BY 1
ORDER BY 1
", time_col, src_name, time_col))) %>% collect()
duckdb_path <- "data/duckdb/madrid.duckdb"
con <- DBI::dbConnect(duckdb::duckdb(), duckdb_path)
on.exit({ try(DBI::dbDisconnect(con, shutdown = TRUE), silent = TRUE) })
src_name <- if ("v_trafico_enriquecido" %in% DBI::dbListTables(con)) "v_trafico_enriquecido" else "trafico_2025_07"
time_col <- intersect(DBI::dbListFields(con, src_name), c("ts", "fecha_hora"))[1]
serie <- tbl(con, dplyr::sql(sprintf("
SELECT date_trunc('minute', %s) AS minuto,
avg(intensidad) AS intensidad_media
FROM %s
WHERE %s >= now() - INTERVAL 2 HOUR
GROUP BY 1
ORDER BY 1
", time_col, src_name, time_col))) %>% collect()
serie <- tbl(con, dplyr::sql(sprintf("
SELECT date_trunc('minute', %s) AS minuto,
avg(intensidad) AS intensidad_media
FROM %s
WHERE %s >= now() - INTERVAL 2 HOUR
GROUP BY 1
ORDER BY 1
", time_col, src_name, time_col))) %>% collect()
suppressPackageStartupMessages({
library(DBI)
library(duckdb)
library(dplyr)
})
duckdb_path <- "data/duckdb/madrid.duckdb"
con <- DBI::dbConnect(duckdb::duckdb(), duckdb_path)
on.exit({ try(DBI::dbDisconnect(con, shutdown = TRUE), silent = TRUE) })
stopifnot("puntos_medida" %in% DBI::dbListTables(con))
suppressPackageStartupMessages({
library(DBI)
library(duckdb)
library(dplyr)
library(dbplyr)
})
duckdb_path <- "data/duckdb/madrid.duckdb"
con <- DBI::dbConnect(duckdb::duckdb(), duckdb_path)
on.exit({ try(DBI::dbDisconnect(con, shutdown = TRUE), silent = TRUE) })
src_name <- if ("v_trafico_enriquecido" %in% DBI::dbListTables(con)) "v_trafico_enriquecido" else "trafico_2025_07"
tr <- dplyr::tbl(con, src_name)
time_col <- intersect(colnames(tr), c("ts", "fecha_hora"))[1]
stopifnot(length(time_col) == 1)
ultimos_30min <- tr %>%
filter(!!sym(time_col) >= dplyr::sql("now() - INTERVAL 30 MINUTE")) %>%
select(!!sym(time_col), idelem, intensidad, ocupacion, nivelServicio) %>%
arrange(desc(!!sym(time_col))) %>%
head(50) %>%
collect()
suppressPackageStartupMessages({
library(DBI)
library(duckdb)
library(dplyr)
library(arrow)
})
duckdb_path <- "data/duckdb/madrid.duckdb"
con <- DBI::dbConnect(duckdb::duckdb(), duckdb_path)
on.exit({ try(DBI::dbDisconnect(con, shutdown = TRUE), silent = TRUE) })
src_name <- if ("v_trafico_enriquecido" %in% DBI::dbListTables(con)) "v_trafico_enriquecido" else "trafico_2025_07"
time_col <- intersect(DBI::dbListFields(con, src_name), c("ts", "fecha_hora"))[1]
out_dir <- "data/processed"
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
resumen <- dplyr::tbl(con, dplyr::sql(sprintf("
SELECT date_trunc('minute', %s) AS minuto,
subarea,
avg(intensidad) AS intensidad_media,
avg(ocupacion)  AS ocupacion_media
FROM %s
WHERE %s >= now() - INTERVAL 60 MINUTE
GROUP BY 1,2
ORDER BY 1 DESC
", time_col, src_name, time_col))) %>% collect()
suppressPackageStartupMessages({
library(DBI)
library(duckdb)
library(dplyr)
library(arrow)
})
duckdb_path <- "data/duckdb/madrid.duckdb"
con <- DBI::dbConnect(duckdb::duckdb(), duckdb_path)
on.exit({ try(DBI::dbDisconnect(con, shutdown = TRUE), silent = TRUE) })
src_name <- if ("v_trafico_enriquecido" %in% DBI::dbListTables(con)) "v_trafico_enriquecido" else "trafico_2025_07"
time_col <- intersect(DBI::dbListFields(con, src_name), c("ts", "fecha_hora"))[1]
out_dir <- "data/processed"
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
resumen <- dplyr::tbl(con, dplyr::sql(sprintf("
SELECT date_trunc('minute', %s) AS minuto,
subarea,
avg(intensidad) AS intensidad_media,
avg(ocupacion)  AS ocupacion_media
FROM %s
WHERE %s >= now() - INTERVAL 60 MINUTE
GROUP BY 1,2
ORDER BY 1 DESC
", time_col, src_name, time_col))) %>% collect()
resumen <- dplyr::tbl(con, dplyr::sql(sprintf("
SELECT date_trunc('minute', %s) AS minuto,
subarea,
avg(intensidad) AS intensidad_media,
avg(ocupacion)  AS ocupacion_media
FROM %s
WHERE %s >= now() - INTERVAL 60 MINUTE
GROUP BY 1,2
ORDER BY 1 DESC
", time_col, src_name, time_col))) %>% collect()
suppressPackageStartupMessages({
library(DBI)
library(duckdb)
library(dplyr)
library(dbplyr)
})
duckdb_path <- "data/duckdb/madrid.duckdb"
con <- DBI::dbConnect(duckdb::duckdb(), duckdb_path)
on.exit({ try(DBI::dbDisconnect(con, shutdown = TRUE), silent = TRUE) })
src_name <- if ("v_trafico_enriquecido" %in% DBI::dbListTables(con)) "v_trafico_enriquecido" else "trafico_2025_07"
tr <- dplyr::tbl(con, src_name)
time_col <- intersect(colnames(tr), c("ts", "fecha_hora"))[1]
stopifnot(length(time_col) == 1)
ultimos_30min <- tr %>%
filter(!!sym(time_col) >= dplyr::sql("now() - INTERVAL 30 MINUTE")) %>%
select(!!sym(time_col), idelem, intensidad, ocupacion, nivelServicio) %>%
arrange(desc(!!sym(time_col))) %>%
head(50) %>%
collect()
suppressPackageStartupMessages({
library(DBI)
library(duckdb)
library(dplyr)
library(leaflet)
})
duckdb_path <- "data/duckdb/madrid.duckdb"
con <- DBI::dbConnect(duckdb::duckdb(), duckdb_path)
on.exit({ try(DBI::dbDisconnect(con, shutdown = TRUE), silent = TRUE) })
src_name <- if ("v_trafico_enriquecido" %in% DBI::dbListTables(con)) "v_trafico_enriquecido" else "trafico_2025_07"
fields <- DBI::dbListFields(con, src_name)
pos_x <- intersect(fields, c("st_x", "lon", "long", "longitude"))
pos_y <- intersect(fields, c("st_y", "lat", "latitude"))
stopifnot(length(pos_x) >= 1, length(pos_y) >= 1)
